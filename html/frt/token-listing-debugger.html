<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Token Listing Debugger - FRT Tools</title>
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        .input-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border: 2px solid #e9ecef;
        }
        
        .mint-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #ced4da;
            border-radius: 8px;
            font-family: monospace;
            margin-bottom: 15px;
        }
        
        .mint-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .preset-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .preset-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .preset-btn:hover {
            background: #5a6268;
        }
        
        .check-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .check-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .check-btn:hover {
            transform: translateY(-2px);
        }
        
        .check-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .output {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            min-height: 300px;
            overflow: auto;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            border: 1px solid #dee2e6;
        }
        
        .clear-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .clear-btn:hover {
            background: #c82333;
        }
        
        .token-image {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            border: 2px solid #dee2e6;
            margin: 10px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .image-container {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            border: 1px solid #dee2e6;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-good { background: #28a745; }
        .status-warning { background: #ffc107; }
        .status-error { background: #dc3545; }
        .status-info { background: #17a2b8; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Token Listing Debugger</h1>
        <p>Debug why your Solana token isn't showing up on exchanges like Raydium, Jupiter, etc.</p>
        
        <div class="input-section">
            <h3>Enter Token Mint Address</h3>
            <input 
                type="text" 
                id="mintInput" 
                class="mint-input" 
                placeholder="Enter SPL token mint address (e.g., tSATdGGSLYBVCrm3pXiib8NmzKcB1iUdjRRseNGssxu)"
                value="tSATdGGSLYBVCrm3pXiib8NmzKcB1iUdjRRseNGssxu"
            />
            
            <div class="preset-buttons">
                <button class="preset-btn" onclick="setPreset('tSATdGGSLYBVCrm3pXiib8NmzKcB1iUdjRRseNGssxu')">tSAT (Example)</button>
                <button class="preset-btn" onclick="setPreset('So11111111111111111111111111111111111111112')">SOL</button>
                <button class="preset-btn" onclick="setPreset('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v')">USDC</button>
                <button class="preset-btn" onclick="setPreset('Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB')">USDT</button>
                <button class="preset-btn" onclick="clearInput()">Clear</button>
            </div>
            
            <div style="display: flex; gap: 10px; align-items: center; justify-content: space-between;">
                <div>
                    <span style="font-size: 14px; color: #6c757d;">Current mint:</span>
                    <code id="currentMint" style="background: #e9ecef; padding: 4px 8px; border-radius: 4px; font-size: 12px;">None selected</code>
                </div>
                <button class="preset-btn" onclick="shareCurrentToken()" title="Copy shareable link">
                    üîó Share Link
                </button>
            </div>
        </div>

        <div class="check-buttons">
            <button class="check-btn" id="checkJupiter" onclick="checkJupiterTokenList()">
                üìã Check Jupiter Lists
            </button>
            <button class="check-btn" id="checkMetadata" onclick="checkTokenMetadata()">
                üè∑Ô∏è Check On-Chain Metadata
            </button>
            <button class="check-btn" id="checkMetadataUri" onclick="checkMetadataUri()">
                üîó Check Metadata URI
            </button>
            <button class="check-btn" id="checkImage" onclick="checkImageUrl()">
                üñºÔ∏è Check Token Image
            </button>
            <button class="check-btn" id="checkPools" onclick="checkRaydiumPools()">
                üèä Check Raydium Pools
            </button>
            <button class="check-btn" id="checkAll" onclick="runAllChecks()">
                ‚úÖ Run All Checks
            </button>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3>Debug Results</h3>
            <div style="display: flex; gap: 8px;">
                <button class="clear-btn" onclick="copyOutput()">üìã Copy Output</button>
                <button class="clear-btn" onclick="clearOutput()">Clear Output</button>
            </div>
        </div>
        
        <div id="imageDisplay" class="image-container" style="display: none;">
            <h4>Token Image Preview</h4>
            <img id="tokenImage" class="token-image" alt="Token Image" />
            <div id="imageInfo" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
        </div>
        
        <div id="output" class="output">Ready to debug tokens! Enter a mint address above and click a check button.</div>
    </div>

    <!-- Load Solana Web3 library -->
    <script src="libs/solana-web3.min.js"></script>
    <script>
    let currentMint = '';
    let currentMetadataUri = '';
    let config = null;

    // IPFS Gateway Management
    const IPFS_GATEWAYS = [
        'https://ipfs.io/ipfs/',
        'https://gateway.pinata.cloud/ipfs/',
        'https://ipfs.filebase.io/ipfs/',
        'https://cloudflare-ipfs.com/ipfs/',
        'https://dweb.link/ipfs/',
        'https://cf-ipfs.com/ipfs/',
        'https://ipfs.infura.io/ipfs/',
        'https://4everland.io/ipfs/'
    ];
    
    const FAILED_GATEWAY_CACHE_KEY = 'ipfs_failed_gateways';
    const CACHE_DURATION = 60 * 60 * 1000; // 1 hour in milliseconds

    // Load configuration
    async function loadConfig() {
        try {
            const response = await fetch('config.json');
            config = await response.json();
            log('Configuration loaded successfully', 'success');
        } catch (e) {
            log('Failed to load config, using fallback RPC', 'warning');
            config = {
                solana: {
                    rpcUrl: 'https://solana-mainnet.core.chainstack.com/36d9fd2485573cf7fc3ec854be754602'
                }
            };
        }
    }

    function updateCurrentMint() {
        const input = document.getElementById('mintInput');
        currentMint = input.value.trim();
        document.getElementById('currentMint').textContent = currentMint || 'None selected';
        
        // Clear stored metadata URI when mint changes
        currentMetadataUri = '';
        window.currentImageUrl = '';
        
        // Enable/disable buttons based on input
        const hasInput = currentMint.length > 0;
        document.querySelectorAll('.check-btn').forEach(btn => {
            btn.disabled = !hasInput;
        });
        
        // Update URL when mint changes (but not during initial load)
        if (document.readyState === 'complete') {
            updateUrlWithMint(currentMint);
        }
    }

    function setPreset(mint) {
        document.getElementById('mintInput').value = mint;
        updateCurrentMint();
    }

    function clearInput() {
        document.getElementById('mintInput').value = '';
        updateCurrentMint();
    }

    function shareCurrentToken() {
        if (!currentMint) {
            alert('Please enter a mint address first');
            return;
        }
        
        const url = new URL(window.location);
        if (currentMint === 'tSATdGGSLYBVCrm3pXiib8NmzKcB1iUdjRRseNGssxu') {
            // For default token, use clean URL
            url.searchParams.delete('mint');
        } else {
            url.searchParams.set('mint', currentMint);
        }
        
        const shareUrl = url.toString();
        
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(shareUrl).then(() => {
                // Temporarily change button text
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                btn.style.background = '#28a745';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#6c757d';
                }, 2000);
            }).catch(err => {
                alert('Failed to copy link: ' + shareUrl);
            });
        } else {
            // Fallback: show the URL
            prompt('Copy this shareable link:', shareUrl);
        }
    }

    function clearOutput() {
        document.getElementById('output').textContent = '';
        // Also hide image display when clearing
        document.getElementById('imageDisplay').style.display = 'none';
    }
    
    function showTokenImage(imageUrl, imageInfo = '') {
        const imageDisplay = document.getElementById('imageDisplay');
        const tokenImage = document.getElementById('tokenImage');
        const imageInfoDiv = document.getElementById('imageInfo');
        
        tokenImage.src = imageUrl;
        imageInfoDiv.textContent = imageInfo;
        imageDisplay.style.display = 'block';
        
        // Add error handler for image loading
        tokenImage.onerror = function() {
            imageInfoDiv.textContent = 'Failed to load image';
            imageInfoDiv.style.color = '#dc3545';
        };
        
        tokenImage.onload = function() {
            const naturalWidth = tokenImage.naturalWidth;
            const naturalHeight = tokenImage.naturalHeight;
            imageInfoDiv.textContent = `${imageInfo} | Dimensions: ${naturalWidth}x${naturalHeight}px`;
            imageInfoDiv.style.color = '#666';
        };
    }

    function log(msg, type = 'info') {
        const output = document.getElementById('output');
        const timestamp = new Date().toLocaleTimeString();
        
        let indicator = '';
        switch(type) {
            case 'success': indicator = '‚úÖ'; break;
            case 'error': indicator = '‚ùå'; break;
            case 'warning': indicator = '‚ö†Ô∏è'; break;
            case 'info': indicator = '‚ÑπÔ∏è'; break;
            default: indicator = '‚Ä¢'; break;
        }
        
        output.textContent += `[${timestamp}] ${indicator} ${msg}\n`;
        output.scrollTop = output.scrollHeight;
    }

    function logSection(title) {
        log(`=== ${title.toUpperCase()} ===`, 'info');
        log(`Token: ${currentMint}`, 'info');
        log(`token-listing-debugger.html`, 'info');
    }

    function copyOutput() {
        const output = document.getElementById('output');
        const text = output.textContent;
        
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(text).then(() => {
                // Temporarily change button text
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                btn.style.background = '#28a745';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#dc3545';
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard');
                console.error('Copy failed:', err);
            });
        } else {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                btn.style.background = '#28a745';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#dc3545';
                }, 2000);
            } catch (err) {
                alert('Failed to copy to clipboard');
            }
            document.body.removeChild(textArea);
        }
    }

    async function checkJupiterTokenList() {
        if (!currentMint) { log('Please enter a mint address first', 'error'); return; }
        
        try {
            logSection('Jupiter Token Lists');
            
            // Check Jupiter strict list
            log('Checking Jupiter STRICT list...');
            const strictResponse = await fetch('https://token.jup.ag/strict');
            const strictTokens = await strictResponse.json();
            const inStrict = strictTokens.find(t => t.address === currentMint);
            
            if (inStrict) {
                log('Found in Jupiter STRICT list', 'success');
                log(`  Symbol: ${inStrict.symbol}`);
                log(`  Name: ${inStrict.name}`);
                log(`  Decimals: ${inStrict.decimals}`);
                log(`  Logo: ${inStrict.logoURI || 'No logo'}`);
                log(`  Tags: ${inStrict.tags?.join(', ') || 'None'}`);
            } else {
                log('NOT in Jupiter strict list', 'error');
            }
            log('===');
            
            // Check Jupiter all list
            log('Checking Jupiter ALL list...');
            const allResponse = await fetch('https://token.jup.ag/all');
            const allTokens = await allResponse.json();
            const inAll = allTokens.find(t => t.address === currentMint);
            
            if (inAll) {
                log('Found in Jupiter ALL list', 'success');
                log(`  Symbol: ${inAll.symbol}`);
                log(`  Name: ${inAll.name}`);
                log(`  Decimals: ${inAll.decimals}`);
                log(`  Logo: ${inAll.logoURI || 'No logo'}`);
                log(`  Tags: ${inAll.tags?.join(', ') || 'None'}`);
            } else {
                log('NOT in Jupiter all list', 'error');
                log('üí° This is likely why exchanges cannot find your token!');
                log('üí° Submit to: https://github.com/jup-ag/token-list');
            }
            log('===');
            
        } catch (e) {
            log('Error checking Jupiter: ' + e.message, 'error');
        }
    }

    async function checkTokenMetadata() {
        if (!currentMint) { log('Please enter a mint address first', 'error'); return; }
        
        try {
            logSection('On-Chain Token Metadata');
            
            // Get metadata PDA
            const METADATA_PROGRAM_ID = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';
            const seeds = [
                new TextEncoder().encode('metadata'),
                new TextEncoder().encode(METADATA_PROGRAM_ID),
                new TextEncoder().encode(currentMint)
            ];
            
            // Use configured RPC endpoint
            const rpcUrl = config?.solana?.rpcUrl || 'https://solana-mainnet.core.chainstack.com/36d9fd2485573cf7fc3ec854be754602';
            const response = await fetch(rpcUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getTokenSupply',
                    params: [currentMint]
                })
            });
            
            const data = await response.json();
            if (data.result) {
                log('Token exists on-chain', 'success');
                log(`  Supply: ${data.result.value.amount}`);
                log(`  Decimals: ${data.result.value.decimals}`);
                log(`  UI Amount: ${data.result.value.uiAmount}`);
            } else {
                log('Token not found on-chain', 'error');
                log('Error: ' + JSON.stringify(data.error));
            }
            log('===');
            
        } catch (e) {
            log('Error checking token metadata: ' + e.message, 'error');
        }
    }

    async function checkMetadataUri() {
        if (!currentMint) { log('Please enter a mint address first', 'error'); return; }
        
        try {
            logSection('Metadata URI Check');
            
            // Clear any previous URI data for this check
            currentMetadataUri = '';
            window.currentImageUrl = '';
            
            console.log('üîç Starting metadata URI check for token:', currentMint);
            
            // Get metadata PDA for this token
            const METADATA_PROGRAM_ID = new solanaWeb3.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
            const [metadataPDA] = solanaWeb3.PublicKey.findProgramAddressSync(
                [
                    new TextEncoder().encode('metadata'),
                    METADATA_PROGRAM_ID.toBytes(),
                    new solanaWeb3.PublicKey(currentMint).toBytes()
                ],
                METADATA_PROGRAM_ID
            );
            
            console.log('üìç Metadata PDA:', metadataPDA.toString());
            log('Fetching metadata account: ' + metadataPDA.toString());
            
            // Fetch metadata account
            const rpcUrl = config?.solana?.rpcUrl || 'https://solana-mainnet.core.chainstack.com/36d9fd2485573cf7fc3ec854be754602';
            const response = await fetch(rpcUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getAccountInfo',
                    params: [
                        metadataPDA.toString(),
                        { encoding: 'base64' }
                    ]
                })
            });
            
            const data = await response.json();
            console.log('üì° RPC Response:', data);
            
            if (data.error) {
                console.error('‚ùå RPC Error:', data.error);
                log('RPC Error: ' + JSON.stringify(data.error), 'error');
                return;
            }
            
            if (!data.result || !data.result.value) {
                console.log('‚ùå No metadata account found');
                log('No metadata account found for this token', 'error');
                log('This token may not have Metaplex metadata', 'warning');
                return;
            }
            
            console.log('‚úÖ Metadata account found, size:', data.result.value.data[0].length, 'bytes');
            log('Metadata account found (' + data.result.value.data[0].length + ' bytes)');
            
            // Decode the metadata to extract URI
            const uri = await decodeMetadataURI(data.result.value.data[0]);
            
            if (uri) {
                currentMetadataUri = uri;
                console.log('‚úÖ Extracted URI:', uri);
                log('Extracted URI: ' + uri);
                await testMetadataUri(uri);
            } else {
                console.log('‚ùå Could not extract URI from metadata');
                log('Could not extract URI from metadata', 'error');
            }
            log('===');
            
        } catch (e) {
            console.error('‚ùå Error in checkMetadataUri:', e);
            log('Error checking metadata URI: ' + e.message, 'error');
        }
    }

    // Decode Metaplex metadata to extract URI (based on token-image.php logic)
    async function decodeMetadataURI(base64Data) {
        try {
            console.log('üîß Starting metadata decode...');
            
            // Convert base64 to bytes
            const buffer = new Uint8Array(atob(base64Data).split('').map(c => c.charCodeAt(0)));
            const view = new DataView(buffer.buffer);
            
            console.log('üìä Buffer length:', buffer.length);
            
            // Skip key (1) + updateAuthority (32) + mint (32) = 65 bytes
            let offset = 65;
            
            if (offset + 4 > buffer.length) {
                console.error('‚ùå Not enough data for name length');
                return null;
            }
            
            // Read name length and skip name
            const nameLen = view.getUint32(offset, true);
            console.log('üìù Name length:', nameLen);
            offset += 4 + nameLen;
            
            if (offset + 4 > buffer.length) {
                console.error('‚ùå Not enough data for symbol length');
                return null;
            }
            
            // Read symbol length and skip symbol
            const symbolLen = view.getUint32(offset, true);
            console.log('üè∑Ô∏è Symbol length:', symbolLen);
            offset += 4 + symbolLen;
            
            if (offset + 4 > buffer.length) {
                console.error('‚ùå Not enough data for URI length');
                return null;
            }
            
            // Read URI length and URI
            const uriLen = view.getUint32(offset, true);
            console.log('üîó URI length:', uriLen);
            offset += 4;
            
            if (offset + uriLen > buffer.length) {
                console.error('‚ùå Not enough data for URI content');
                return null;
            }
            
            const uri = new TextDecoder().decode(buffer.slice(offset, offset + uriLen)).replace(/\0/g, '');
            console.log('‚úÖ Extracted URI:', uri);
            
            return uri.trim();
            
        } catch (e) {
            console.error('‚ùå Error decoding metadata:', e);
            return null;
        }
    }

    async function testMetadataUri(uri) {
        console.log('üîó Testing metadata URI:', uri);
        
        // Extract IPFS hash if it's an IPFS URL
        const ipfsHash = extractIpfsHash(uri);
        console.log('üìù IPFS hash:', ipfsHash);
        
        let metadata = null;
        
        // If it's an IPFS URL, use smart gateway selection
        if (ipfsHash) {
            const originalGateway = getGatewayBase(uri);
            const workingGateways = getWorkingGateways();
            
            // Check if original gateway is in working list
            if (originalGateway && workingGateways.includes(originalGateway)) {
                metadata = await tryFetchMetadata(uri, 'Original URI');
            } else if (originalGateway) {
                console.log('üö´ Skipping original gateway (marked as failed):', originalGateway);
                log('Skipping original gateway (marked as failed): ' + originalGateway, 'warning');
            }
            
            // If original failed or was skipped, try other working gateways
            if (!metadata) {
                let gatewaysToTry = workingGateways.filter(gw => gw !== originalGateway);
                
                if (gatewaysToTry.length === 0) {
                    log('All IPFS gateways are marked as failed. Clearing cache and retrying...', 'warning');
                    clearFailedGatewayCache();
                    gatewaysToTry = IPFS_GATEWAYS.filter(gw => gw !== originalGateway);
                }
                
                for (const gateway of gatewaysToTry) {
                    const fallbackUri = gateway + ipfsHash;
                    console.log('üîÑ Trying gateway:', fallbackUri);
                    metadata = await tryFetchMetadata(fallbackUri, 'IPFS gateway');
                    if (metadata) break;
                }
            }
        } else {
            // Non-IPFS URL, try directly
            metadata = await tryFetchMetadata(uri, 'Original URI');
        }
        
        if (metadata) {
            log('Metadata successfully loaded', 'success');
            log('Metadata content:');
            log(JSON.stringify(metadata, null, 2));
            
            // Check required fields
            if (metadata.name) log('‚úì Has name: ' + metadata.name, 'success');
            else log('‚úó Missing name field', 'error');
            
            if (metadata.symbol) log('‚úì Has symbol: ' + metadata.symbol, 'success');
            else log('‚úó Missing symbol field', 'error');
            
            if (metadata.image) {
                log('‚úì Has image: ' + metadata.image, 'success');
                // Store for image check and try fallbacks for image too
                window.currentImageUrl = metadata.image;
                window.currentImageIpfsHash = extractIpfsHash(metadata.image);
            } else {
                log('‚úó Missing image field', 'error');
            }
            
            if (metadata.description) log('‚úì Has description', 'success');
            else log('‚ö† Missing description (recommended)', 'warning');
        } else {
            log('All metadata URI attempts failed', 'error');
        }
    }

    // IPFS Gateway Cache Management
    function getFailedGateways() {
        try {
            const cached = localStorage.getItem(FAILED_GATEWAY_CACHE_KEY);
            if (!cached) return {};
            
            const failedGateways = JSON.parse(cached);
            const now = Date.now();
            
            // Remove expired entries
            Object.keys(failedGateways).forEach(gateway => {
                if (now - failedGateways[gateway] > CACHE_DURATION) {
                    delete failedGateways[gateway];
                }
            });
            
            // Save cleaned cache
            localStorage.setItem(FAILED_GATEWAY_CACHE_KEY, JSON.stringify(failedGateways));
            return failedGateways;
        } catch (e) {
            console.warn('Failed to load gateway cache:', e);
            return {};
        }
    }

    function markGatewayAsFailed(gateway) {
        try {
            const failedGateways = getFailedGateways();
            failedGateways[gateway] = Date.now();
            localStorage.setItem(FAILED_GATEWAY_CACHE_KEY, JSON.stringify(failedGateways));
            console.log('üö´ Marked gateway as failed:', gateway);
        } catch (e) {
            console.warn('Failed to cache gateway failure:', e);
        }
    }

    function clearFailedGatewayCache() {
        try {
            localStorage.removeItem(FAILED_GATEWAY_CACHE_KEY);
            console.log('üßπ Cleared failed gateway cache');
            log('Cleared failed gateway cache', 'info');
        } catch (e) {
            console.warn('Failed to clear gateway cache:', e);
        }
    }

    function getWorkingGateways() {
        const failedGateways = getFailedGateways();
        const workingGateways = IPFS_GATEWAYS.filter(gateway => !failedGateways[gateway]);
        
        console.log('üîç Available gateways:', workingGateways.length, 'of', IPFS_GATEWAYS.length);
        if (Object.keys(failedGateways).length > 0) {
            console.log('üö´ Failed gateways:', Object.keys(failedGateways));
        }
        
        return workingGateways;
    }

    // Extract IPFS hash from URL
    function extractIpfsHash(url) {
        const ipfsRegex = /\/ipfs\/([a-zA-Z0-9]{46,})/;
        const match = url.match(ipfsRegex);
        return match ? match[1] : null;
    }

    // Get gateway base URL from full URL
    function getGatewayBase(url) {
        const match = url.match(/(https?:\/\/[^\/]+\/ipfs\/)/);
        return match ? match[1] : null;
    }

    // Try to fetch metadata from a URI with timeout and gateway caching
    async function tryFetchMetadata(uri, source, timeout = 10000) {
        const gatewayBase = getGatewayBase(uri);
        
        try {
            console.log(`üåê Trying ${source}:`, uri);
            log(`Trying ${source}: ${uri}`);
            
            // Create fetch with timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            const response = await fetch(uri, { 
                signal: controller.signal,
                headers: {
                    'Accept': 'application/json'
                }
            });
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                console.log(`‚ùå ${source} failed:`, response.status, response.statusText);
                log(`${source} failed: ${response.status} ${response.statusText}`, 'error');
                
                // Mark gateway as failed if it's an IPFS gateway
                if (gatewayBase && IPFS_GATEWAYS.includes(gatewayBase)) {
                    markGatewayAsFailed(gatewayBase);
                }
                return null;
            }
            
            const metadata = await response.json();
            console.log(`‚úÖ ${source} success!`);
            log(`${source} accessible`, 'success');
            return metadata;
            
        } catch (e) {
            console.log(`‚ùå ${source} error:`, e.message);
            
            if (e.name === 'AbortError') {
                log(`${source} timed out after ${timeout/1000}s`, 'error');
                console.log(`‚è∞ ${source} timed out`);
            } else {
                log(`${source} error: ${e.message}`, 'error');
            }
            
            // Mark gateway as failed if it's an IPFS gateway
            if (gatewayBase && IPFS_GATEWAYS.includes(gatewayBase)) {
                markGatewayAsFailed(gatewayBase);
            }
            return null;
        }
    }

    async function checkImageUrl() {
        if (!currentMint) { log('Please enter a mint address first', 'error'); return; }
        
        try {
            logSection('Token Image Check');
            
            if (!window.currentImageUrl) {
                log('No image URL available. Run metadata URI check first.', 'warning');
                return;
            }
            
            const imageUrl = window.currentImageUrl;
            log('Image URL: ' + imageUrl);
            
            let imageResult = null;
            
            // Use smart gateway selection for IPFS images
            if (window.currentImageIpfsHash) {
                const originalGateway = getGatewayBase(imageUrl);
                const workingGateways = getWorkingGateways();
                
                // Check if original gateway is in working list
                if (originalGateway && workingGateways.includes(originalGateway)) {
                    imageResult = await tryFetchImage(imageUrl, 'Original image URL');
                } else if (originalGateway) {
                    console.log('üö´ Skipping original image gateway (marked as failed):', originalGateway);
                    log('Skipping original image gateway (marked as failed): ' + originalGateway, 'warning');
                }
                
                // If original failed or was skipped, try other working gateways
                if (!imageResult) {
                    let gatewaysToTry = workingGateways.filter(gw => gw !== originalGateway);
                    
                    if (gatewaysToTry.length === 0) {
                        log('All IPFS gateways are marked as failed. Clearing cache and retrying...', 'warning');
                        clearFailedGatewayCache();
                        gatewaysToTry = IPFS_GATEWAYS.filter(gw => gw !== originalGateway);
                    }
                    
                    for (const gateway of gatewaysToTry) {
                        const fallbackUri = gateway + window.currentImageIpfsHash;
                        console.log('üîÑ Trying image gateway:', fallbackUri);
                        imageResult = await tryFetchImage(fallbackUri, 'IPFS image gateway');
                        if (imageResult) {
                            // Update the working URL for display
                            window.currentImageUrl = fallbackUri;
                            break;
                        }
                    }
                }
            } else {
                // Non-IPFS image, try directly
                imageResult = await tryFetchImage(imageUrl, 'Original image URL');
            }
            
            if (imageResult) {
                log('Valid image content type', 'success');
                
                // Display the image
                const fileSizeKB = imageResult.contentLength ? Math.round(imageResult.contentLength / 1024) : 'Unknown';
                showTokenImage(window.currentImageUrl, `${imageResult.contentType} | ${fileSizeKB}KB`);
                log('üñºÔ∏è Image displayed above', 'success');
            } else {
                log('All image URL attempts failed', 'error');
                log('This will prevent proper token display', 'warning');
            }
            log('===');
            
        } catch (e) {
            log('Error checking image: ' + e.message, 'error');
        }
    }

    // Try to fetch image from a URL with timeout and gateway caching
    async function tryFetchImage(imageUrl, source, timeout = 8000) {
        const gatewayBase = getGatewayBase(imageUrl);
        
        try {
            console.log(`üñºÔ∏è Trying ${source}:`, imageUrl);
            log(`Trying ${source}: ${imageUrl}`);
            
            // Create fetch with timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            const response = await fetch(imageUrl, { 
                method: 'HEAD',
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            
            if (response.ok) {
                const contentType = response.headers.get('content-type');
                const contentLength = response.headers.get('content-length');
                
                console.log(`‚úÖ ${source} accessible:`, contentType, contentLength + ' bytes');
                log(`${source} accessible`, 'success');
                log(`Content-Type: ${contentType}`);
                log(`Content-Length: ${contentLength} bytes`);
                
                if (contentType && contentType.startsWith('image/')) {
                    return { contentType, contentLength };
                } else {
                    log('Invalid content type for image', 'error');
                    return null;
                }
            } else {
                console.log(`‚ùå ${source} failed:`, response.status, response.statusText);
                log(`${source} not accessible: ${response.status}`, 'error');
                
                // Mark gateway as failed if it's an IPFS gateway
                if (gatewayBase && IPFS_GATEWAYS.includes(gatewayBase)) {
                    markGatewayAsFailed(gatewayBase);
                }
                return null;
            }
            
        } catch (e) {
            console.log(`‚ùå ${source} error:`, e.message);
            
            if (e.name === 'AbortError') {
                log(`${source} timed out after ${timeout/1000}s`, 'error');
                console.log(`‚è∞ ${source} timed out`);
            } else {
                log(`${source} error: ${e.message}`, 'error');
            }
            
            // Mark gateway as failed if it's an IPFS gateway
            if (gatewayBase && IPFS_GATEWAYS.includes(gatewayBase)) {
                markGatewayAsFailed(gatewayBase);
            }
            return null;
        }
    }

    async function checkRaydiumPools() {
        if (!currentMint) { log('Please enter a mint address first', 'error'); return; }
        
        try {
            logSection('Raydium Pools Check');
            
            log('Checking Raydium pools...');
            
            // Try the API endpoint with proper error handling
            const response = await fetch('https://api.raydium.io/v2/sdk/liquidity/mainnet.json');
            
            if (!response.ok) {
                log(`Raydium API error: ${response.status} ${response.statusText}`, 'error');
                return;
            }
            
            const text = await response.text();
            if (!text.trim()) {
                log('Empty response from Raydium API', 'error');
                return;
            }
            
            let data;
            try {
                data = JSON.parse(text);
            } catch (parseError) {
                log('Failed to parse Raydium API response', 'error');
                log('Response preview: ' + text.substring(0, 200) + '...', 'info');
                return;
            }
            
            if (!data.official || !Array.isArray(data.official)) {
                log('Unexpected Raydium API response format', 'error');
                log('Available keys: ' + Object.keys(data).join(', '), 'info');
                return;
            }
            
            const pools = data.official.filter(pool => 
                pool.baseMint === currentMint || pool.quoteMint === currentMint
            );
            
            if (pools.length > 0) {
                log(`Found ${pools.length} Raydium pool(s)`, 'success');
                pools.forEach((pool, i) => {
                    log(`\nPool ${i + 1}: ${pool.id}`);
                    log(`  Base: ${pool.baseMint} (${pool.baseSymbol || 'Unknown'})`);
                    log(`  Quote: ${pool.quoteMint} (${pool.quoteSymbol || 'Unknown'})`);
                    log(`  LP Mint: ${pool.lpMint}`);
                });
            } else {
                log('No Raydium pools found', 'error');
                log('Token needs liquidity pools to appear in Raydium', 'warning');
                log('Create pool at: https://raydium.io/liquidity/create-pool/', 'info');
            }
            log('===');
            
        } catch (e) {
            log('Error checking Raydium pools: ' + e.message, 'error');
            log('This could be a temporary API issue or network problem', 'warning');
        }
    }

    async function runAllChecks() {
        if (!currentMint) { log('Please enter a mint address first', 'error'); return; }
        
        clearOutput();
        log('üöÄ Running all checks for: ' + currentMint, 'info');
        
        // Ensure config is loaded
        if (!config) {
            await loadConfig();
        }
        
        await checkTokenMetadata();
        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay
        
        await checkJupiterTokenList();
        await new Promise(resolve => setTimeout(resolve, 500));
        
        await checkMetadataUri();
        await new Promise(resolve => setTimeout(resolve, 500));
        
        await checkImageUrl();
        await new Promise(resolve => setTimeout(resolve, 500));
        
        await checkRaydiumPools();
        
        log('\nüèÅ All checks completed!', 'success');
    }

    // Event listeners
    document.getElementById('mintInput').addEventListener('input', updateCurrentMint);
    document.getElementById('mintInput').addEventListener('paste', () => {
        setTimeout(updateCurrentMint, 100);
    });

    // Get mint from URL parameter or use default
    function getMintFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const mintParam = urlParams.get('mint');
        return mintParam || 'tSATdGGSLYBVCrm3pXiib8NmzKcB1iUdjRRseNGssxu'; // Default to tSAT
    }

    // Update URL when mint changes
    function updateUrlWithMint(mint) {
        if (!mint) return;
        
        const url = new URL(window.location);
        if (mint === 'tSATdGGSLYBVCrm3pXiib8NmzKcB1iUdjRRseNGssxu') {
            // Remove mint parameter for default token to keep URL clean
            url.searchParams.delete('mint');
        } else {
            url.searchParams.set('mint', mint);
        }
        
        // Update URL without reloading page
        window.history.replaceState({}, '', url);
    }

    // Initialize
    document.getElementById('mintInput').value = getMintFromUrl();
    updateCurrentMint();
    loadConfig();
    </script>
</body>
</html>
